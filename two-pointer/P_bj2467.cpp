/*
21m

백준 2467 - 용액

알고리즘 : 두포인터

문제 개요 : 정수가 n개 정렬된 채로 주어지고 그들중 두수를 더했을때 0에 가까운 두 숫자를 출력

생각해볼 부분 : 처음에 맨끝에서 인덱스가 0,n-1인 부분끼리 비교한후

만약 두 합이 음수면 0을 이동시키고, 양수면 n-1을 이동시키는 것이 모든 경우에서 확실한지에 대한 정당성

-> 그 이유는 만약 양끝점이 a(0), a(n-1) 이라고 할때 두 합이 양수라고 하자.

이때 두합이 양수라는 것은 우리가 목표로 하는 0을 만드는것으로 볼때 음수측이 더 커져야한다.

동시에 양수쪽이 커질수록 답이 반드시될수 없다.

따라서 우리가 할수 있는 행위(a(0) -> a(1) 으로 옮기기 or a(n-1) -> a(n-2)로 옮기기) 중에

전자의 행위는 전체합을 이전보다 증가시킬수 밖에 없다. 따라서 이전보다 더 큰 양수가 나오므로 0과 더 멀어질수밖에 없다.

따라서 두합이 양수면 양수측에서 0쪽으로 옮기고, 음수면 음수측에서 0으로 옮겨야한다.

*/

#include <iostream>

using namespace std;

int n;
int arr[100001];

int main(){
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> arr[i];
    }

    if(arr[0] < 0 && arr[n-1] < 0){ // 모든 입력이 알칼리
        cout << arr[n-2] << " " << arr[n-1];
    }
    else if(arr[0] > 0 && arr[n-1] > 0){ // 모든 입력이 산성 
        cout << arr[0] << " " << arr[1];
    }
    else{
        int p1,p2,minimum;
        int save1,save2;
        p1 = 0;
        p2 = n-1;
        minimum = 1100000000;
        while(p1 != p2){
            if(abs(arr[p1] + arr[p2]) < minimum){
                minimum = abs(arr[p1] + arr[p2]);
                save1 = p1;
                save2 = p2; 
            }
            if(arr[p1] + arr[p2] > 0){
                p2 = p2 - 1;
            }
            else{
                p1 = p1 + 1;
            }
        }
        cout << arr[save1] << " " << arr[save2];
    }
}