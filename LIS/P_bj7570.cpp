/*/////////////////////////////////////////////////////////////////////////
날짜 : 2021.09.21

소요시간 : 30m

문제명 - 백준 7570 줄세우기
+ 2631 줄세우기 문제가 lis 알고리즘인것 같다.(더쉬움)
   
알고리즘
    - 최장증가수열(lis?) *항상 연속해야함

문제개요

    - 문제 및 아이디어

    1부터 N까지 랜덤하게 수열이 주어지고 하나의 숫자를 선택해서 맨앞으로 보내거나 맨뒤로 보낼수 있다.
    이때 가장 최소 횟수로 이동시켜서 오름차순 수열로 만드는 횟수 출력.

    예제(5 2 4 1 3)에서 2,3을 제외한 5,4,1을 옮기는 것을 주의깊게 살폈다.

    2,3빼고 나머지 세 숫자를 움직인 이유는 2,3은 이미 오름차순으로 연속해서 수열을 구성하고 있으므로
    (물론 거리는 떨어져 있지만) 나머지 숫자들 중 2보다 작은 수들은 큰수부터, 3보다 큰 수들은 작은수부터
    각각 앞뒤로 보내면 오름차순을 구성할 수 있기 때문이다.

    따라서 일반적으로 단조 증가인 lis가 아닌 항상 순차적으로 증가하는 부분수열중에(거리가 떨어져 있어도 되는)
    가장 긴 수열의 원소개수가 p개라고 했을때, 전체 n개중에서 p개를 뺀 나머지만큼만 움직이는 것이
    최소일 것이다.

    그래서 n-p가 답이 될것이다.

    - 구현

    k번째 숫자를 확인할 때 k번째에 있는 숫자를 q라고 하자.
    
    q라는 숫자와 연속된 숫자를 확인할 때는 먼저 q라는 숫자 이전에 q-1 이라는 숫자가 나왔었는지가 중요하다.

    1) 만약 q-1이 나왔었다면 q-1, q 이 두숫자는 연속이다.
    2) 만약 q-1이 안나왔었다면 q는 본인이 가장 시작점이다.

    또한 2)의 경우에는 q본인이 자신을 포함하는 연속수열의 부분집합중에 가장 선두(root) 이다.

    그러나 1)의 경우에는 q보다 q-1이 이전에 존재하므로 q-1이 선두일 수도 있고, q-1이전에 
    q-2나 q-3... 등 선두가 존재할 수도 있으므로 현재까지 자신앞에 몇명이 존재했었는지 기록이
    필요하다. 그것이 counts[] 이다.

    만약 counts[10] = 3 이라면 10이라는 숫자(10번째에 있는숫자가 아니다. 진짜 10이라는 숫자를 의미한다.)
    를 포함해서 3개가 연속으로 존재했다는 것이고 즉

    x x 8 x x 9 x 10
    8 9 x x x 10 x x
    x x x x 8 x 9 x 10

    등등 위와같이 8,9,10이 그들간에 사이에 거리는 떨어져있을 수도 있지만 연속해서 존재한다는 의미이다.

    따라서 이런식으로 모든 수열을 확인하면 counts[] 값들중에 가장 큰 값이 가장 길게 순차적으로 
    증가하는 수열의 길이일 것이고, 그것이 위의 p값이다.

    따라서 n-p 값이 최종적인 답이 될것이다.


   
*//////////////////////////////////////////////////////////////////////////



#include <iostream>

using namespace std;

int n;
int arr[1000001];
int visited[1000001];
int counts[1000001];

int main(){
    cin >> n;
    for(int i=0;i<n;i++){
        cin >> arr[i];
        visited[i] = -1;
        counts[i] = 0;
    }
    int now;
    for(int i=0;i<n;i++){ // 연속으로 증가하는 수열중 가장 길이 찾기
        now = arr[i];
        visited[now] = 1;
        if(now == 1){
            counts[now] = 1;
        }
        else{
            // 현재 숫자의 이전 숫자가 아직 발견되지 않은 상태
            if(visited[now-1] == -1){
                counts[now] = 1;
            }
            // 현재 숫자의 이전 숫자가 이전에 이미 발견된 상태
            else{
                counts[now] = counts[now-1] + 1;
            }
        }
    }
    int maxi = 0;
    for(int i=1;i<n+1;i++){
        if(counts[i] > maxi){
            maxi = counts[i];
        }
    }
    int ans = (n-maxi);
    cout << ans;
}